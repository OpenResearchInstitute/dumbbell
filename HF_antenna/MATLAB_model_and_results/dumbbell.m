% Create a dipoleMeander antenna
% Generated by MATLAB(R) 9.14 and Antenna Toolbox 5.4.
% Started on: 13-May-2023 08:00:20

%% radiation resistance and efficiency model

% from the 1958 Heaviside paper
% sin(x) squared graph, over 256 foot aerial
aerial_length = 256;
x = 0:pi/18:pi;
y = sin(x).*sin(x);

% recreate the A, B, C, D points on the graph in the paper

idx = [1, 5, 8, 12, 15, 19]   % the index of the location of the labels
labels = {'A', 'B', 'C', 'D', 'E', 'F'};   % list of the labels in the paper
x_offset = [0, -0.05, -0.075, 0.075, 0.05, 0]   % makes the labels much prettier


figure
p = plot(x, y, "-o", "Color", "k", "LineWidth", 2)
for ind = 1:length(labels)
    disp(x(idx(ind)))
text((x(idx(ind))) + x_offset(ind), y(idx(ind)) + 0.05, labels(ind), "Color", "b","FontSize", 18, "HorizontalAlignment", "center")
end

% Let's do some animation?
ABx = x(1:5)
ABy = y(1:5)
CDx = x(8:12)
CDy = y(8:12)
centerx = x(1:10)
centery = y(1:10)

hold on
area(ABx, ABy,"FaceColor","c" )
area(CDx, CDy, "FaceColor","g")
hold off

figure
hold on
p = plot(x, y, "-o", "Color", "k", "LineWidth", 2)
for ind = 1:length(labels)
    disp(x(idx(ind)))
text((x(idx(ind))) + x_offset(ind), y(idx(ind)) + 0.05, labels(ind), "Color", "b","FontSize", 18, "HorizontalAlignment", "center")
end
area(centerx, centery, "FaceColor", "b")
hold off

%% N5ESE antenna calculations

% But there is a method by which the portion acting as an aerial can be
% made to act as the center portion. This method causes the current, after
% reflection at the insulator, to build up to maximum in the aerial by
% putting the required length of wire between the aerial proper and the
% insulator. This special length of wire must be wound non-inductively and
% spaced at least 1 inch and of a length equal to a quarter wavelength for
% the band in use, minus one half the length of the aerial top. 



% This "loading coil" can be wound around a cylinder or flattened out in in
% a tab or wing or two-dimensional area. 

% 12 foot 7 band "doublet" has 11.5 feet in each loading coil, and 5 feet
% of radiator on each side.

n5ese_length_ft = 11.5+11.5+5+5;



%% parameters
% 7.1 MHz half wavelength is 21.126760563380284 m
% 7.1 MHz half wavelength is 69.29577464788733

% 7.2 MHz half wavelength is 20.833333333333332 m
% 7.2 MHz half wavelength is 68.33333333333333 ft

% 3.75 MHz half wavelength is 131.2 ft
% 3.75 MHz half wavelength is 40 m

% 1.9 MHz half wavelength is 258.94736842105266 ft
% 1.9 MHz half wavelength is 78.94736842105263 m

% take the middle one third of the structure for the radiating element
frequency = 14.2e6  % in Hz
fut = 23.65e6 % in Hz, fut  is frequency under test, which centers it where it seemed to perform best
c = 299792458   % speed of light in m/s

wavelength = c/frequency 
radiatorLength = wavelength/6 % one third of a half wave dipole in meters

u = symunit;
radiatorLength_ft = unitConvert(radiatorLength*u.m, u.ft)
[len units] = separateUnits(radiatorLength_ft);
len = double(len) % one third of a half wave dipole in feet. 

%% Notch Length set

% if the folded elements are executed with a one inch gap,
% then set 
% antennaObject.NotchLength = 0.0254 m (one inch)
% this is the top horizonal length of the folded element. 

% antennaObject.NotchWidth is the height of the folded elements.

% the second through N values of 
% antennaObject.ArmLength are the bottom horizontal length
% of the folded element. We want this to be one inch too. Use NotchLength
% for that too.

% so now we solve for something space efficient. 
% perhaps a square? Let's get to as close a square shape as we can.

% we know the lenghth of wire in the folded element sections.
% it's equal to radiatorLength. 

% we know NotchLength = ArmLength 2 ... N = 0.0254 m
% we know the height and width of our square folded element
% will be equal to each other. This is antennaObject.NotchWidth 
% We just need to come up with the right expression.
% This one is brute force, which is not a great tactic.
% we did this at the gym that day. Need to recreate it.


NotchLength = 0.0254;

%% determine number of humps in folded section
%radiatorLength = numHumps*(2*NotchWidth + 2*NotchLength)

%NotchRun = numHumps*2*NotchLength

%NotchWidth = height of folded elements = NotchRun
%substitute in NotchRun for NotchLength 

%radiatorLength = numHumps*(2*(numHumps*2*NotchLength) + 2*NotchLength)
%radiatorLength = numHumps*(4*numHumps*NotchLength + 2*NotchLength)
%radiatorLength = 4*NotchLength*numHumps^2 + 2*NotchLength*numHumps
%we can use the quadratic equation
% 0 = 4*NotchLength*numHumps^2 + 2*NotchLength*numHumps - radiatorLength
A = 4*NotchLength;
B = 2*NotchLength;
C = -radiatorLength;

numHumps = ((-B)+((B^2-4*A*C))^0.5)/(2*A)
numHumps_2= ((-B)-((B^2-4*A*C))^0.5)/(2*A);

% NotchRun is the horizontal length of the folded element section
% NotchWidth is the vertical length of the folded element section

% in N5ESE's version, we see
% 12 feet of cable with up 1 foot up 1 foot over 1 foot down 1 foot over as one hump, 
% so there are 3 humps each 4 feet long 

% pick the floor or ceiling of this to get an integer result, and then recalculate the
% NotchWidth. 

integerNumHumps = floor(numHumps)

%radiatorLength = numHumps*(2*NotchWidth + 2*NotchLength)
finalNotchWidth = (radiatorLength - 2*integerNumHumps*NotchLength)/(integerNumHumps*2)

% for an outdoor installation, put the inductive load around a cylinder. Do
% this with acrylic disks or somethign like that. We have the NotchRun,
% which is notch length times the integral number of humps. 

NotchRun = integerNumHumps*NotchLength*2

%% determine cowling diameter

cowlingDiameter = NotchRun/pi
cowlingDiameter_in = unitConvert(cowlingDiameter*u.m, u.in)
[dia units] = separateUnits(cowlingDiameter_in);
dia = double(dia) % diameter of the two disks in inches to make the cowling 

% we need to separate the wires by an inch. Install one inch wide square
% teeth separated by a one inch gap all the way around the cowling disks. 

% in order to draw a diagram, we need some points around a circle.
% theta runs from -pi to pi and has a point every pi/180 radians, or every
% 1 degree.

theta = [-pi:pi/36:pi]

% 2*integer number of humps is the number of tooth edges around a circle.
% 2*pi/2*5 humps is how many radians are between tooth edges.
% tooth defines enough points to draw a gear tooth or gap.
% tooth is 0 to (2*pi/2*integer number of humps), with values every pi/180
% (1 degree)

tooth = [pi/180:pi/180:(2*pi/(2*integerNumHumps))]

%draw the cowling
figure
hold on
%draw the outer edges of the gear teeth
%we draw every other tooth
inx = [1:2*integerNumHumps] % set up an array with an index for edge tooth edge
%we're going to draw every other tooth, so collect up the tooth edges that
%correspond to the places where every other tooth starts. I picked odds.
inx_odds = inx(1:2:end) 

%draw the outer edge of a tooth then rotate a full tooth then draw another
%tooth.
for i = 1:length(inx_odds)
    plot( ((cowlingDiameter + NotchLength)/2)* cos(tooth+inx_odds(i)*((2*pi)/integerNumHumps)),  ((cowlingDiameter + NotchLength)/2) * sin(tooth+inx_odds(i)*((2*pi)/integerNumHumps)), "LineWidth", 3)
end

% draw original cowling diameter
plot(cowlingDiameter/2 * cos(theta), cowlingDiameter/2 * sin(theta), "LineWidth", 3 )
hold on

% draw lines indicating where the gear teeth are
for r=[1:2*integerNumHumps]
line([cowlingDiameter/2*cos(r*2*pi/(2*integerNumHumps)) (cowlingDiameter+NotchLength)/2*cos(r*2*pi/(2*integerNumHumps))], ...
    [cowlingDiameter/2*sin(r*2*pi/(2*integerNumHumps)) (cowlingDiameter+NotchLength)/2*sin(r*2*pi/(2*integerNumHumps))], "LineWidth", 3)
end

% we know the angle, chord length = 2*r*sin(theta/2)
% calculate arc length, circumference/(2*pi/10) <== use this number to
% calculate a new radius for the chord length.

arc_length = (cowlingDiameter*pi)*(2*pi/(2*integerNumHumps))/(2*pi);

chord_length = 2*(cowlingDiameter/2)*sin((2*pi/(2*integerNumHumps))/2);

optimized_cowlingDiameter = arc_length/sin((2*pi/(2*integerNumHumps))/2);

outside_diameter = optimized_cowlingDiameter + NotchLength;

%draw the optimized diameter that accounts for the wire going across the
%chord instead of following the arc of a circular gear lacing system.
plot( (optimized_cowlingDiameter/2)* cos(theta), (optimized_cowlingDiameter/2) * sin(theta), "LineWidth", 3)
hold off

%% Antenna Properties 

antennaObject = dipoleMeander;
antennaObject.Width = 0.002623;
%antennaObject.ArmLength = [7.3152, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254, 0.0254];
antennaObject.ArmLength = [radiatorLength, repmat(NotchLength, 1, integerNumHumps)]

antennaObject.NotchLength = 0.0254;
antennaObject.NotchWidth = finalNotchWidth;
% Show
figure
show(antennaObject) 

%% Antenna Analysis 
% Define plot frequency 
plotFrequency = fut; %using the frequency where we saw the best SWR?
% Define frequency range for analysis and visualizations
% This could be and possibly should be parameterized, but let's model 40m to 10m
% Here are some other ways of doing it:
%freqRange = (0.5*plotFrequency:0.1*plotFrequency:1.5*plotFrequency);
%testFreqRange = (1.6*frequency: 0.01*frequency:2*frequency);
% here is the fixed range we're using right now:
freqRange = (7e6:100e3:28e6)
% Reference Impedance 
refImpedance = 50;


%% calcluations

% impedance
%figure;
%impedance(antennaObject, freqRange)

% Antenna is typically constructed using wires. Use the wireStack 
% function to convert the strip model to a wire model. You cannot 
% change the geometric properties of the antenna. However, you can 
% set the FeedLocation, FeedVoltage, Tilt, and TiltAxis properties. 
% To update the geometrical properties such as ArmLength and Width, 
% you must convert the wire model back to the strip model.

wireAntennaObject = wireStack(antennaObject)

% show the antenna
figure
show(wireAntennaObject)

% impedance of wire antenna
figure
impedance(wireAntennaObject, freqRange)

% produce antenna pattern
figure
pattern(wireAntennaObject, plotFrequency)

% Antenna efficiency of microstrip antenna
figure
efficiency(antennaObject, freqRange)

% Charge distribution on antenna
figure
charge(wireAntennaObject, plotFrequency)

% Current distribution on antenna
figure
current(wireAntennaObject, plotFrequency)

%% Attempt Smith chart
%d = dipole;  % we have a wireAntennaObject 
%freq = linspace(60e6, 90e6, 200); % we have testFreqRange
figure 
s_50 = sparameters(wireAntennaObject, freqRange, 50);
hg = smithplot(s_50,[1,1]);
hg.LegendLabels = {"S11 at 50#ohm"};
hg.LineWidth = 2;

%% Attempt to add coax cable to analysis
%Model the Effect of Coaxial Cable

%The coaxial cable connected to the fabricated dumbell antenna is a LMR-400 with a 
% characteristic impedance of 50 Î©. Create a model of this coaxial cable using RF Toolbox.

out_radius = 0.0813/2; %Overall Braid Diameter: 0.320in (8.13mm). function wants meters!
in_radius = 0.0274/2; % 2.74mm is the inner conductor diameter. function wants meters!
eps_r = 1.38; % we think it's 1.38 for LMR400. This is close to the default.
line_length = 23.8; % in meters

coax_cable = rfckt.coaxial;
coax_cable.OuterRadius = out_radius;
coax_cable.InnerRadius = in_radius;
coax_cable.EpsilonR = eps_r;
coax_cable.LossTangent = 2e-4;
coax_cable.LineLength = line_length;

% Analyze the coaxial cable at the range of frequencies intended for operation
% and use the antenna's impedance as the load. 
% Compute the input VSWR for the coaxial cable and dumbbell antenna.

Zantenna =impedance(wireAntennaObject, freqRange);
analyze(coax_cable, freqRange, Zantenna);
figure
hline = plot(coax_cable,'VSWRin','None');
hline.LineWidth = 2;

%% Special Operations
%openExample('antenna/atx_farfield_visualization')

% Define Spatial Plane Extent
lambda = physconst('lightspeed')/plotFrequency;
SpatialInfo.XSpan = 0.4*lambda; % was 5*lambda
SpatialInfo.YSpan = 0.4*lambda;
SpatialInfo.ZSpan = 0.4*lambda;
SpatialInfo.NumPointsX = 400;
SpatialInfo.NumPointsY = 400;
SpatialInfo.NumPointsZ = 400;
% Define Time Extent
Tperiod = 1/plotFrequency;
T = 2*Tperiod; % was 2
TimeInfo.TotalTime = T;
TimeInfo.SamplingTime = [];
% Define E-Field Data details
DataInfo.Component = 'Ex';
DataInfo.PlotPlane = 'XZ';
DataInfo.DataLimits = [-2 6];
DataInfo.ScaleFactor = 1;
DataInfo.GifFileName = 'dumbbellEz.gif';
DataInfo.CloseFigure = true;
%% Animate
helperAnimateEHFields(antennaObject,plotFrequency,SpatialInfo, TimeInfo, DataInfo)
writeaAnimation("dumbbellEz.gif") %helper function saves it for us already, I think. 
